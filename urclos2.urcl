// THIS IS A BETA AND BUGS MAY BE PRESENT

// URCL OS v2

// Whats new in v2:
// Rewrite of all functions
// New intermediate language
// Terminal upgrades (more to come as well)
// Directories
// New file header format (easier to access information and scales better)

// Included programs: ls (0 or /0/0), cd (1 or /0/1)

// URCL HEADER
BITS >= 16
MINREG 4
MINHEAP 128
MINSTACK 6

// Load files (using STR)
// / (root)
// Format: {name} {format} {length} {address} (8 files in root)
STR M0, 0x0262
STR M1, 0x0001
STR M2, 0x0009
STR M3, M39
STR M4, 0
//M5-M32 should contain 0 but unnecessary in this case)
// /0 (/bin)
STR M33, 0x0262 //3 long name starts with b (bin)
STR M34, 0x0001 //format: directory
STR M35, 0x0009 //length
STR M36, M39 //address of start
STR M37, 0x0069 //continuation of name (i)
STR M38, 0x006E //continuation of name (n)
STR M39, 0x016C //2 long name starts with l (ls)
STR M40, 0x0000 //format: program
STR M41, 0x002C //length
STR M42, M54 //address of start
STR M43, 0x0163 //2 long name starts with c (cd)
STR M44, 0x0000 //format: program
STR M45, 0x0008 //length
STR M46, M104
STR M47, 0 //padding
STR M48, 0 //padding between files
// /0/0 (/bin/ls)
STR M49, 0x016C //2 long name starts with l (ls)
STR M50, 0x0000 //format: program
STR M51, 0x002D //length
STR M52, M54 //address of start
STR M53, 0x0073 //continuation of name (s)
STR M54, 0x7001 //imm r7, 0x000A '\n'
STR M55, 0x000A //immediate word
STR M56, 0x8001 //imm r8, 8
STR M57, 0x0008 //immediate word
STR M58, 0x9001 //imm r9, 0x00FF
STR M59, 0x00FF //immediate word
STR M60, 0xA001 //imm r10, 0x3A ':'
STR M61, 0x003A //immediate word
STR M62, 0xB001 //imm r11, 0x20 ' '
STR M63, 0x0020 //immediate word
STR M64, 0xC001 //imm r12, 3
STR M65, 0x0003 //immediate word
STR M66, 0xD001 //imm r13, .loop
STR M67, 0x0015 //immediate word
STR M68, 0xE001 //imm r14, .loop2
STR M69, 0x0024 //immediate word
STR M70, 0xF001 //imm r15, .end
STR M71, 0x002B //immediate word
STR M72, 0x5001 //imm r5, 0x30 ('0')
STR M73, 0x0030 //immediate word
STR M74, 0x401C //dec r4
STR M75, 0x401B //inc r4 (.loop)
STR M76, 0x1413 //lod r1, r4
STR M77, 0xF10C //brz r15, r1
STR M78, 0x2115 //mov r2, r1
STR M79, 0x280B //bsr r2, r8 (8)
STR M80, 0x1908 //and r1, r9
STR M81, 0x511D //outc r5
STR M82, 0xA11D //outc r10
STR M83, 0xB11D //outc r11
STR M84, 0x111D //outc r1
STR M85, 0x501B //inc r5
STR M86, 0x4C02 //add r4, r12
STR M87, 0xD20C //brz r13, r2
STR M88, 0x1413 //lod r1, r4
STR M89, 0x1203 //sub r1, r2
STR M90, 0x6113 //lod r6, r1 (.loop2)
STR M91, 0x611D //outc r6
STR M92, 0x201C //dec r2
STR M93, 0x101B //inc r1
STR M94, 0xE20D //bnz r14, r2
STR M95, 0x711D //outc r7
STR M96, 0xD012 //jmp r13
STR M97, 0x001E //hlt
STR M98, 0
// /0/1 (/bin/cd)
STR M99, 0x0163 //2 long name starts with c (cd)
STR M100, 0x0000 //format: program
STR M101, 0x0007 //length
STR M102, M104 //address of start
STR M103, 0x0064 //continuation of name (d)
STR M104, 0x2017 //pop r2
STR M105, 0xF001 //imm r15, 0xb (.root)
STR M106, 0x000B //immediate word
STR M107, 0x1001 //imm r1, 0x30
STR M108, 0x0030 //immediate word
STR M109, 0x2103 //sub r2, r1
STR M110, 0x21DD //cdFromCurrent r2
STR M111, 0x001E // hlt
STR M112, 0

JMP .Initialize
// Instruction to Address Table
.InstructionTable
DW 0
DW .Immediate // 1
DW .Add // 2
DW .Subtract // 3
DW .Multiply // 4
DW .Divide // 5
DW .Modulo // 6
DW .Xor // 7
DW .And // 8
DW .Or // 9
DW .ShiftLeft // 10
DW .ShiftRight // 11
DW .BranchIfZero // 12
DW .BranchIfNotZero // 13
DW .BranchIfEqual // 14
DW .BranchIfNotEqual // 15
DW .BranchIfLessThan // 16
DW .BranchIfGreaterThan // 17
DW .Jump // 18
DW .LoadMemory // 19
DW .StoreMemory // 20
DW .Move // 21
DW .Push // 22
DW .Pop // 23
DW .Call // 24
DW .Return // 25
DW .Add2Word // 26
DW .Increment // 27
DW .Decrement // 28
DW .SystemCall // 29
DW .Halt // 30
DW .Error // 31

// System Calls
.SystemCalls
DW .Exit // 0
DW .DriveAddr // 1
DW .DriveRead // 2
DW .DriveWrite // 3
DW .CallProgram // 4
DW .CallProgramFromDirectory // 5
DW .DeviceNumber // 6
DW .InChar // 7
DW .OutChar // 8
DW .InString // 9 (Coming soon)
DW .OutString // 10 (Coming soon)
DW .InHex // 11
DW .OutHex // 12
DW .ChangeWorkingDirectory // 13
DW .ChangeWorkingDirectoryFromCurrent // 14

//* Interpreter Variables *//
.Pointer // Stores the address of the next instruction to be executed
DW 0x0000

.ProgramLimit // Stores the limit of the program currently executed (global address) (inclusive)
DW 0x0000

//* File Scan Variables *//
.MaxFiles // Stores the maximum amount of files in the root directory multiplied by 4 (Total = maximum amount of file info words)
DW 0x0020

.LengthOfFile // Stores the length of the file
DW 0x0000

//* Other OS Variables *//
.VirtualRegisters
DW 0 // R0 (Set to 0 before each program)
DW 0 // R1
DW 0 // R2
DW 0 // R3
.R4
DW M0 // R4
DW 0 // R5
DW 0 // R6
DW 0 // R7
DW 0 // R8
DW 0 // R9
DW 0 // R10
DW 0 // R11
DW 0 // R12
DW 0 // R13
DW 0 // R14
.JumpDest
DW 0 // Jump Dest (R15)

.Stackpointer
DW 0

.CurrentWorkingDirectory
DW M0

.RootDirectory
DW M0

.StartupProgram // Coming soon
DW 0

//* Constants *//
.ProgramMemoryLimit // Stores the limit of the memory for programs (inclusive)
DW 0xFFFF // 65535

.Runram // Stores whether cpu is runram (1 if runram, 0 if runrom)
DW 1

.Bits // Stores the amount of bits of the cpu
//DW 0 //incase &BITS does not work in compiler/emulator (cough cough mod)
DW &BITS

.MemoryAvailable // Stores the amount of memory available to the cpu
DW 0xFFFF

.Mem0
DW M0

.Initialize
STR .Stackpointer, SP //initialize starting sp

JMP .Shell
.ShellEnd
POP R1
BNE .ShellEnd, R1, 0
.Shell
OUT %TEXT, 0x24
PSH 0
MOV R2, SP
.ShellLoop
IN R1, %TEXT
OUT %TEXT, R1
PSH R1
BNE .ShellLoop, R1, 0xA
//if first char null or : exit
LOD R1, .CurrentWorkingDirectory
DEC R2, R2
LOD R3, R2
BRE .ShellEnd, R3, 0xA // Exit if null
BRE .ShellEnd, R3, 0x3A // Exit if ':'
BRE .ChangeToRoot, R3, 0x2F
BRE .FileFindLoop, R3, 0x2E
//if first char not / look in /bin
LOD R4, .RootDirectory
LLOD R4, R4, 3
STR .CurrentWorkingDirectory, R4
JMP .FileFindLoopSkipDec
//if first char / follow directory starting from root
.ChangeToRoot
LOD R4, .RootDirectory
STR .CurrentWorkingDirectory, R4
//if first char . follow directory from current
.FileFindLoop
DEC R2, R2
LOD R3, R2
.FileFindLoopSkipDec
BRE .FileFindLoop, R3, 0x2F //ignore if slash
BRE .ProgramFound, R3, 0xA
BRE .ProgramFound, R3, 0x20
SUB R3, R3, 0x30
LOD R4, .CurrentWorkingDirectory
BSL R3, R3, 2
ADD R3, R3, 3
ADD R4, R3, R4
LOD R3, R4
STR .CurrentWorkingDirectory, R3
JMP .FileFindLoop
.ProgramFound
LOD R2, .CurrentWorkingDirectory
BRZ .Error, R2 //exit if fake offbrand directory
STR .CurrentWorkingDirectory, R1 //reset wd
BGE .SubWDSkip, R1, M0
SUB R1, R1, .InstructionTable
.SubWDSkip
STR .R4, R1
POP R1
//jump to program

.RunProgram
    //IN R1, %TEXT // Get file index
    //OUT %TEXT, R1
    //SUB R1, R1, 0x30 // Move it to "0" = 0
    //BSL R1, R1, 2 // Multiply it by 4 to get an address to the file table
    //ADD R1, R1, 3 // Point it to the global address
    //LOD R2, .MaxFiles
    //BRG .Error, R1, R2
    //LOD R2, .CurrentWorkingDirectory
    //ADD R1, R1, R2 // Point to the file table
    //LOD R2, R1
    STR .Pointer, R2 // .Pointer = R1
    DEC R1, R2
    //set .ProgramLimit to the limit of the file (inclusive) (read description of the variable)
    LLOD R4, R4, -1
    ADD R2, R2, R4
    STR .ProgramLimit, R2

    
.InterpretationLoop // The loop that is ran for running a program (calling .Execute per instruction)
    // Prepare for next program being executed (reset variables)
    STR .VirtualRegisters, 0 // Set R0 to 0
    
    // R1 = Pointer
    // R3 = Temp
    .Loop3
        INC R1, R1 // Update PC
        // Check if reached the end of a program
        LOD R3, .ProgramLimit
        BRG .ShellEnd, R1, R3

        // R4 = full operation
        // R2 = instruction
        LOD R4, R1 // R2 = mem[R1(pointer)]
        AND R2, R4, 0x001F // instruction = R2

        .Execute
            BRZ .Loop3, R2 //exit if no instruction
            ADD R2, R2, .InstructionTable //add offset to instruction table
            LOD R2, R2 //load jump address
            JMP R2 //call instruction

    .EndLoop3

//* INSTRUCTIONS *//

// 11112222000IIIII
// I = instruction
// 1, 2 = operand
// 0 = only used in system call
.Immediate
AND R2, R4, 0xF000 // R2 = op1
BSR R2, R2, 12
INC R1, R1 // Inc pointer
LOD R3, R1 // Load the immediate
ADD R2, .VirtualRegisters, R2 // Add offset
STR R2, R3 // Store the immediate
JMP .Loop3

.Add
CAL .Get2op
ADD R4, R4, R3 // Do the addition
STR R2, R4
JMP .Loop3

.Subtract
CAL .Get2op
SUB R4, R4, R3 // Do the subtraction
STR R2, R4
JMP .Loop3

.Multiply
CAL .Get2op
MLT R4, R4, R3 // Do the multiplication
STR R2, R4
JMP .Loop3

.Divide
CAL .Get2op
DIV R4, R4, R3 // Do the division
STR R2, R4
JMP .Loop3

.Modulo
CAL .Get2op
MOD R4, R4, R3 // Do the modulo
STR R2, R4
JMP .Loop3

.Xor
CAL .Get2op
XOR R4, R4, R3 // Do the bitwise xor
STR R2, R4
JMP .Loop3

.And
CAL .Get2op
AND R4, R4, R3 // Do the bitwise and
STR R2, R4
JMP .Loop3

.Or
CAL .Get2op
OR R4, R4, R3 // Do the bitwise or
STR R2, R4
JMP .Loop3

.ShiftLeft
CAL .Get2op
BSL R3, R4, R3
STR R2, R3
JMP .Loop3

.ShiftRight
CAL .Get2op
BSR R3, R4, R3
STR R2, R3
JMP .Loop3

.BranchIfZero
CAL .Get2op
BNZ .BRZend, R3
LOD R3, .Pointer
ADD R4, R4, R3
MOV R1, R4
DEC R1, R1
.BRZend
JMP .Loop3

.BranchIfNotZero
CAL .Get2op
BRZ .BNZend, R3
LOD R3, .Pointer
ADD R4, R4, R3
MOV R1, R4
DEC R1, R1
.BNZend
JMP .Loop3

.BranchIfEqual
CAL .Get2op
BNE .BREend, R4, R3
LOD R3, .JumpDest
LOD R4, .Pointer
ADD R1, R3, R4
DEC R1, R1
.BREend
JMP .Loop3

.BranchIfNotEqual
CAL .Get2op
BRE .BNEend, R4, R3
LOD R3, .JumpDest
LOD R4, .Pointer
ADD R1, R3, R4
DEC R1, R1
.BNEend
JMP .Loop3

.BranchIfGreaterThan
CAL .Get2op
BLE .BRGend, R4, R3
LOD R3, .JumpDest
LOD R4, .Pointer
ADD R1, R3, R4
DEC R1, R1
.BRGend
JMP .Loop3

.BranchIfLessThan
CAL .Get2op
BGE .BRLend, R4, R3
LOD R3, .JumpDest
LOD R4, .Pointer
ADD R1, R3, R4
DEC R1, R1
.BRLend
JMP .Loop3

.Jump
CAL .Get1op
LOD R4, .Pointer
ADD R1, R4, R3
DEC R1, R1
JMP .Loop3

.LoadMemory
CAL .Get2op
BGE .OutOfSource, R3, M0
ADD R3, R3, .InstructionTable
.OutOfSource
LOD R3, R3
STR R2, R3
JMP .Loop3

.StoreMemory
CAL .Get2op
BGE .OutOfSource2, R4, M0
ADD R4, R4, .InstructionTable
.OutOfSource2
STR R4, R3
JMP .Loop3

.Move
CAL .Get2op
STR R2, R3
JMP .Loop3

.Push
CAL .Get1op
PSH R3
STR .Stackpointer, SP
JMP .Loop3

.Pop
CAL .Get1op
POP R3
STR R2, R3
STR .Stackpointer, SP
JMP .Loop3

.Call
CAL .Get1op
LOD R4, .Pointer
ADD R4, R4, R3
MOV R1, R3
DEC R1, R1
PSH R4
JMP .Loop3

.Return
POP R1
JMP .Loop3

.Add2Word //award for most painful instruction to impliment
AND R2, R4, 0xF000 // R2 = op1
BSR R2, R2, 12
ADD R2, R2, .VirtualRegisters
PSH R2
LOD R2, R2
LLOD R3, R2, 1
AND R4, R4, 0x0F00 // R4 = op2
BSR R4, R4, 8
ADD R4, R4, .VirtualRegisters
PSH R4
LOD R4, R4
BNC .AddNoCarry, R4, R2
INC R3, R3
.AddNoCarry
ADD R4, R4, R2
POP R2
LLOD R2, R2, 1
ADD R3, R3, R2
POP R2
STR R2, R4
LSTR R2, 1, R3
JMP .Loop3

.Increment
CAL .Get1op
INC R3, R3
STR R2, R3
JMP .Loop3

.Decrement
CAL .Get1op
DEC R3, R3
STR R2, R3
JMP .Loop3

.SystemCall
AND R2, R4, 0x0FE0 // R2 = op1
BSR R2, R2, 5
ADD R2, R2, .SystemCalls // Add offset
LOD R3, R2 // Load jump address
JMP R3

.Halt
JMP .ShellEnd

//System Calls
.Exit
HLT

.DriveAddr
CAL .Get1op
OUT %ADDR, R3
JMP .Loop3

.DriveRead
CAL .Get1op
IN R3, %BUS
JMP .Loop3

.DriveWrite
CAL .Get1op
OUT %BUS, R3
JMP .Loop3

.CallProgram
CAL .Get1op
.CallprogramOpPresent
STR .Pointer, R3 //set pointer
MOV R1, R3 //set program counter
STR .VirtualRegisters, 0 //set 0 reg
JMP .Loop3

.CallProgramFromDirectory
CAL .Get1op
BSL R3, R3, 2 //mult by 4
ADD R3, R3, 3
LOD R4, .CurrentWorkingDirectory //load current working directory
ADD R3, R3, R4 //add offset
LOD R3, R3 //load address
JMP .CallprogramOpPresent

.DeviceNumber
CAL .Get1op
OUT %PROFILE, R3
JMP .Loop3

.InChar
AND R2, R4, 0xF000 // R2 = op1
BSR R2, R2, 12
ADD R2, R2, .VirtualRegisters
IN R3, %TEXT
STR R2, R3
JMP .Loop3

.OutChar
CAL .Get1op
OUT %TEXT, R3
JMP .Loop3

.InString // Coming soon
.OutString // Coming soon
JMP .Error

.InHex
AND R2, R4, 0xF000 // R2 = op1
BSR R2, R2, 12
ADD R2, R2, .VirtualRegisters
PSH R2
IMM R4, 16
IMM R2, 0
.Loop4
SUB R4, R4, 4
IN R3, %TEXT
SUB R3, R3, 0x30
BRL .HexInSkip, R3, 0xA
SUB R3, R3, 7
.HexInSkip
BSL R3, R3, R4
OR R2, R2, R3
BNZ .Loop4, R4
POP R3
STR R3, R2
JMP .Loop3

.OutHex
AND R2, R4, 0xF000 // R2 = op1
BSR R2, R2, 12
ADD R2, R2, .VirtualRegisters
LOD R3, R2
AND R3, R3, 0xF000
BSR R3, R3, 12
ADD R3, R3, 0x30
BRL .HexOut1, R3, 0x3A
ADD R3, R3, 7
.HexOut1
OUT %TEXT, R3
AND R3, R2, 0x0F00
AND R4, R2, 0x00F0
AND R2, R2, 0x000F
BSR R3, R3, 8
BSR R4, R4, 4
ADD R3, R3, 0x30
BRL .HexOut2, R3, 0x3A
ADD R3, R3, 7
.HexOut2
OUT %TEXT, R3
ADD R4, R4, 0x30
BRL .HexOut3, R4, 0x3A
ADD R4, R4, 7
.HexOut3
OUT %TEXT, R4
ADD R2, R2, 0x30
BRL .HexOut4, R2, 0x3A
ADD R2, R2, 7
.HexOut4
OUT %TEXT, R2
JMP .Loop3

.ChangeWorkingDirectory
CAL .Get1op
STR .CurrentWorkingDirectory, R3
JMP .Loop3

.ChangeWorkingDirectoryFromCurrent
CAL .Get1op
BRE .CDFCroot, R3, 0xFFFF
BSL R3, R3, 2 //mult by 4
ADD R3, R3, 3
LOD R4, .CurrentWorkingDirectory //load current working directory
ADD R3, R3, R4 //add offset
LOD R3, R3 //load address
STR .CurrentWorkingDirectory, R3
JMP .Loop3
.CDFCroot
LOD R3, .RootDirectory
STR .CurrentWorkingDirectory, R3
JMP .Loop3

//* EXTRA FUNCTIONS *//
.Error
OUT %TEXT, 0x45 // 'E'
OUT %TEXT, 0x72 // 'r'
OUT %TEXT, 0x72 // 'r'
OUT %TEXT, 0x6F // 'o'
OUT %TEXT, 0x72 // 'r'
OUT %TEXT, 0xA // '\n'
JMP .ShellEnd

.Get2op
AND R2, R4, 0xF000 // R2 = op1
AND R3, R4, 0x0F00 // R3 = op2
BSR R2, R2, 12
BSR R3, R3, 8
ADD R2, .VirtualRegisters, R2 // Add offset
ADD R3, .VirtualRegisters, R3
LOD R4, R2
LOD R3, R3 // Load values
RET

.Get1op
AND R2, R4, 0xF000 // R2 = op1
BSR R2, R2, 12
ADD R2, R2, .VirtualRegisters
LOD R3, R2
RET
