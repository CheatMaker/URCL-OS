// THIS IS A BETA AND BUGS MAY BE PRESENT

// URCL OS v2

// Whats new in v2:
// Rewrite of all functions
// New intermediate language
// Terminal upgrades (more to come as well)
// Directories
// New file header format (easier to access information and scales better)

// Included programs: ls (0 or /0/0), cd (1 or /0/1)

// URCL HEADER
BITS >= 16
MINREG 4
MINHEAP 200
MINSTACK 6

// Load files (using STR)
// /0 (/bin)
STR M108, 0x0262 //3 long name starts with b (bin)
STR M109, 0x0001 //format: directory
STR M110, 0x0004 //length (-1)
STR M111, M114 //address of start
STR M112, 0x0069 //continuation of name (i)
STR M113, 0x006E //continuation of name (n)
STR M114, 0x016C //2 long name starts with l (ls)
STR M115, 0x0000 //format: program
STR M116, 0x001B //length (-1)
STR M117, M129 //address of start
STR M118, 0x0163 //2 long name starts with c (cd)
STR M119, 0x0000 //format: program
STR M120, 0x000E //length (-1)
STR M121, M163
STR M122, 0 //padding
STR M123, 0 //padding between files
// /0/0 (/bin/ls)
STR M124, 0x016C //2 long name starts with l (ls)
STR M125, 0x0000 //format: program
STR M126, 0x001B //length (-1)
STR M127, M129 //address of start
STR M128, 0x0073 //continuation of name (s)
STR M129, 0x1001 //imm r1, 0x30 '0'
STR M130, 0x0030 //immediate word
STR M131, 0x2001 //imm r2, 0x3A ':'
STR M132, 0x003A //immediate word
STR M133, 0x5001 //imm r5, 0x20 ' '
STR M134, 0x0020 //immediate word
STR M135, 0x6001 //imm r6, 0x0A '\n'
STR M136, 0x000A //immediate word
STR M137, 0x7001 //imm r7, 27 (.escape)
STR M138, 0x001B //immediate word
STR M139, 0x8001 //imm r8, 0x10 (.loop)
STR M140, 0x0010 //immediate word
STR M141, 0x9001 //imm r9, 4
STR M142, 0x0004 //immediate word
STR M143, 0xA001 //imm r10, 0xFF
STR M144, 0x00FF //immediate word
STR M145, 0x3413 //lod r3, r4
STR M146, 0x3A08 //and r3, r10
STR M147, 0x730C //brz r7, r3
STR M148, 0x111D //outchar r1
STR M149, 0x211D //outchar r2 ':'
STR M150, 0x511D //outchar r5 ' '
STR M151, 0x311D //outchar r3
STR M152, 0x611D //outchar r6 '\n'
STR M153, 0x4902 //add r4, r9
STR M154, 0x101B //inc r1
STR M155, 0x8012 //jmp r8
STR M156, 0x001E //hlt .escape
STR M157, 0
// /0/1 (/bin/cd)
STR M158, 0x0163 //2 long name starts with c (cd)
STR M159, 0x0000 //format: program
STR M160, 0x000E //length (-1)
STR M161, M163 //address of start
STR M162, 0x0064 //continuation of name (d)
STR M163, 0x2017 //pop r2
STR M164, 0xF001 //imm r15, 0xb (.root)
STR M165, 0x000B //immediate word
STR M166, 0x4001 //imm r4, 0x5E
STR M167, 0x005E //immediate word
STR M168, 0x240E //bre r2, r4
STR M169, 0x1001 //imm r1, 0x30
STR M170, 0x0030 //immediate word
STR M171, 0x2103 //sub r2, r1
STR M172, 0x21DD //cdFromCurrent r2
STR M173, 0x001E // hlt
STR M174, 0x2001 // .root imm r2, 0xffff
STR M175, 0xFFFF //immediate word
STR M176, 0x21DD //cdFromCurrent r2
STR M177, 0x001E //hlt

.Initialize
// Instruction to Address Table
.InstructionTable
STR M0, 0
STR M1, .Immediate // 1
STR M2, .Add // 2
STR M3, .Subtract // 3
STR M4, .Multiply // 4
STR M5, .Divide // 5
STR M6, .Modulo // 6
STR M7, .Xor // 7
STR M8, .And // 8
STR M9, .Or // 9
STR M10, .ShiftLeft // 10
STR M11, .ShiftRight // 11
STR M12, .BranchIfZero // 12
STR M13, .BranchIfNotZero // 13
STR M14, .BranchIfEqual // 14
STR M15, .BranchIfNotEqual // 15
STR M16, .BranchIfLessThan // 16
STR M17, .BranchIfGreaterThan // 17
STR M18, .Jump // 18
STR M19, .LoadMemory // 19
STR M20, .StoreMemory // 20
STR M21, .Move // 21
STR M22, .Push // 22
STR M23, .Pop // 23
STR M24, .Call // 24
STR M25, .Return // 25
STR M26, .Add2Word // 26
STR M27, .Increment // 27
STR M28, .Decrement // 28
STR M29, .SystemCall // 29
STR M30, .Halt // 30
STR M31, .Error // 31

// System Calls
.SystemCalls
STR M32, .Exit // 0
STR M33, .DriveAddr // 1
STR M34, .DriveRead // 2
STR M35, .DriveWrite // 3
STR M36, .CallProgram // 4
STR M37, .CallProgramFromDirectory // 5
STR M38, .DeviceNumber // 6
STR M39, .InChar // 7
STR M40, .OutChar // 8
STR M41, .InString // 9 (Coming soon)
STR M42, .OutString // 10 (Coming soon)
STR M43, .InHex // 11
STR M44, .OutHex // 12
STR M45, .ChangeWorkingDirectory // 13
STR M46, .ChangeWorkingDirectoryFromCurrent // 14

//* Interpreter Variables *//
.Pointer // Stores the address of the next instruction to be executed
STR M47, 0x0000

.ProgramLimit // Stores the limit of the program currently executed (global address) (inclusive)
STR M48, 0x0000

//* File Scan Variables *//
.MaxFiles // Stores the maximum amount of files in the root directory multiplied by 4 (Total = maximum amount of file info words)
STR M49, 0x0020

.Placeholder // nobody knows
STR M50, 0x0000

//* Other OS Variables *//
.VirtualRegisters
STR M51, 0 // R0 (Set to 0 before each program)
STR M52, 0 // R1
STR M53, 0 // R2
STR M54, 0 // R3
STR M55, M76 // R4 //.files
STR M56, 0 // R5
STR M57, 0 // R6
STR M58, 0 // R7
STR M59, 0 // R8
STR M60, 0 // R9
STR M61, 0 // R10
STR M62, 0 // R11
STR M63, 0 // R12
STR M64, 0 // R13
STR M65, 0 // R14
.JumpDest
STR M66, 0 // Jump Dest (R15)

.Stackpointer
STR M67, SP

.CurrentWorkingDirectory
STR M68, M76 //.files

.RootDirectory
STR M69, M76 //.files

.StartupProgram // Coming soon
STR M70, 0

//* Constants *//
.ProgramMemoryLimit // Stores the limit of the memory for programs (inclusive)
STR M71, 0xFFFF // 65535

.Runram // Stores whether cpu is runram (1 if runram, 0 if runrom)
STR M72, 0

.Bits // Stores the amount of bits of the cpu
//STR M73, &BITS please please please &BITS please

.MemoryAvailable // Stores the amount of memory available to the cpu
STR M74, 0xFFFF

.Mem0
STR M75, M108
//* Files *//
.Files // Space for 8 files Format: {name} {format} {length} {address}
STR M76, 0
STR M77, 0
STR M78, 0
STR M79, 0
STR M80, 0
STR M81, 0
STR M82, 0
STR M83, 0
STR M84, 0
STR M85, 0
STR M86, 0
STR M87, 0
STR M88, 0
STR M89, 0
STR M90, 0
STR M91, 0
STR M92, 0
STR M93, 0
STR M94, 0
STR M95, 0
STR M96, 0
STR M97, 0
STR M98, 0
STR M99, 0
STR M100, 0
STR M101, 0
STR M102, 0
STR M103, 0
STR M104, 0
STR M105, 0
STR M106, 0
STR M107, 0

.ScanFiles //scan for files on drive
    // Scans the files stored in memory and writes their info on the file info table (.Files)

    LOD R1, M68 //.CurrentWorkingDirectory R1 = File Table Address
    IMM R2, M108 // R2 = Address of the file currently scanning

    LOD R3, R2 // R3 = data of header of file
    BRZ .Shell, R3 // Exit if no file

    .Loop2
        // name
        STR R1, R3 // Store the data on the file table

        // format
        LLOD R3, R2, 1 // R3 = data of header of file
        LSTR R1, 1, R3 // Store the data on the file table

        // length
        LLOD R4, R2, 2 // R3 = data of header of file
        LSTR R1, 2, R4 // Store the data on the file table

        // address
        LLOD R3, R2, 3 // R3 = data of header of file
        LSTR R1, 3, R3 // Store the data on the file table

        ADD R1, R1, 4
        ADD R2, R2, 4
        // jump to the end of the file
        INC R4, R4
        ADD R2, R3, R4 // Increment by length of file so that the index is at the start of the next file
        LOD R3, R2 //check if 0
        BRZ .EndLoop2, R3 // end if no more file
        JMP .Loop2
    .EndLoop2

JMP .Shell
.ShellEnd
POP R1
BNE .ShellEnd, R1, 0
.Shell
OUT %TEXT, 0x24
PSH 0
MOV R2, SP
.ShellLoop
IN R1, %TEXT
OUT %TEXT, R1
PSH R1
BNE .ShellLoop, R1, 0xA
//if first char null or : exit
LOD R1, M68 //.CurrentWorkingDirectory
DEC R2, R2
LOD R3, R2
BRE .ShellEnd, R3, 0xA // Exit if null
BRE .ShellEnd, R3, 0x3A // Exit if ':'
BRE .ChangeToRoot, R3, 0x2F
BRE .FileFindLoop, R3, 0x2E
//if first char not / look in /bin
LOD R4, M69 //.RootDirectory
LLOD R4, R4, 3
STR M68, R4 //.CurrentWorkingDirectory
JMP .FileFindLoopSkipDec
//if first char / follow directory starting from root
.ChangeToRoot
LOD R4, M69 //.RootDirectory
STR M68, R4 //.CurrentWorkingDirectory
//if first char . follow directory from current
.FileFindLoop
DEC R2, R2
LOD R3, R2
.FileFindLoopSkipDec
BRE .FileFindLoop, R3, 0x2F //ignore if slash
BRE .ProgramFound, R3, 0xA
BRE .ProgramFound, R3, 0x20
SUB R3, R3, 0x30
LOD R4, M68 //.CurrentWorkingDirectory
BSL R3, R3, 2
ADD R3, R3, 3
ADD R4, R3, R4
LOD R3, R4
STR M68, R3 //.CurrentWorkingDirectory
JMP .FileFindLoop
.ProgramFound
LOD R2, M68 //.CurrentWorkingDirectory
BRZ .Error, R2 //exit if fake offbrand directory
STR M68, R1 //.CurrentWorkingDirectory reset wd
STR M55, R1 //R4
POP R1
//jump to program

.RunProgram
    //IN R1, %TEXT // Get file index
    //OUT %TEXT, R1
    //SUB R1, R1, 0x30 // Move it to "0" = 0
    //BSL R1, R1, 2 // Multiply it by 4 to get an address to the file table
    //ADD R1, R1, 3 // Point it to the global address
    //LOD R2, .MaxFiles
    //BRG .Error, R1, R2
    //LOD R2, .CurrentWorkingDirectory
    //ADD R1, R1, R2 // Point to the file table
    //LOD R2, R1
    STR M47, R2 // .Pointer = R2
    DEC R1, R2
    //set .ProgramLimit to the limit of the file (inclusive) (read description of the variable)
    DEC R4, R4
    LOD R4, R4
    ADD R2, R1, R4
    STR M48, R2

    JMP .InterpretationLoop // Start executing program
    
.InterpretationLoop // The loop that is ran for running a program (calling .Execute per instruction)
    // Prepare for next program being executed (reset variables)
    STR M51, 0 // Set R0 to 0
    
    // R1 = Pointer
    // R3 = Temp
    .Loop3
        INC R1, R1 // Update PC
        // Check if reached the end of a program
        LOD R3, M48
        BRG .ShellEnd, R1, R3

        // R4 = full operation
        // R2 = instruction
        LOD R4, R1 // R2 = mem[R1(pointer)]
        AND R2, R4, 0x001F // instruction = R2

        .Execute
            BRZ .Loop3, R2 //exit if no instruction
            ADD R2, R2, M0 //add offset to instruction table
            LOD R2, R2 //load jump address
            JMP R2 //call instruction

    .EndLoop3

//* INSTRUCTIONS *//

// 11112222000IIIII
// I = instruction
// 1, 2 = operand
// 0 = only used in system call
.Immediate
AND R2, R4, 0xF000 // R2 = op1
BSR R2, R2, 12
INC R1, R1 // Inc pointer
LOD R3, R1 // Load the immediate
ADD R2, M51, R2 // Add offset
STR R2, R3 // Store the immediate
JMP .Loop3

.Add
CAL .Get2op
ADD R4, R4, R3 // Do the addition
STR R2, R4
JMP .Loop3

.Subtract
CAL .Get2op
SUB R4, R4, R3 // Do the subtraction
STR R2, R4
JMP .Loop3

.Multiply
CAL .Get2op
MLT R4, R4, R3 // Do the multiplication
STR R2, R4
JMP .Loop3

.Divide
CAL .Get2op
DIV R4, R4, R3 // Do the division
STR R2, R4
JMP .Loop3

.Modulo
CAL .Get2op
MOD R4, R4, R3 // Do the modulo
STR R2, R4
JMP .Loop3

.Xor
CAL .Get2op
XOR R4, R4, R3 // Do the bitwise xor
STR R2, R4
JMP .Loop3

.And
CAL .Get2op
AND R4, R4, R3 // Do the bitwise and
STR R2, R4
JMP .Loop3

.Or
CAL .Get2op
OR R4, R4, R3 // Do the bitwise or
STR R2, R4
JMP .Loop3

.ShiftLeft
CAL .Get2op
BSL R3, R4, R3
STR R2, R3
JMP .Loop3

.ShiftRight
CAL .Get2op
BSR R3, R4, R3
STR R2, R3
JMP .Loop3

.BranchIfZero
CAL .Get2op
BNZ .BRZend, R3
LOD R3, M47
ADD R4, R4, R3
MOV R1, R4
DEC R1, R1
.BRZend
JMP .Loop3

.BranchIfNotZero
CAL .Get2op
BRZ .BNZend, R3
LOD R3, M47
ADD R4, R4, R3
MOV R1, R4
DEC R1, R1
.BNZend
JMP .Loop3

.BranchIfEqual
CAL .Get2op
BNE .BREend, R4, R3
LOD R3, M66
LOD R4, M47
ADD R1, R3, R4
DEC R1, R1
.BREend
JMP .Loop3

.BranchIfNotEqual
CAL .Get2op
BRE .BNEend, R4, R3
LOD R3, M66
LOD R4, M47
ADD R1, R3, R4
DEC R1, R1
.BNEend
JMP .Loop3

.BranchIfGreaterThan
CAL .Get2op
BLE .BRGend, R4, R3
LOD R3, M66
LOD R4, M47
ADD R1, R3, R4
DEC R1, R1
.BRGend
JMP .Loop3

.BranchIfLessThan
CAL .Get2op
BGE .BRLend, R4, R3
LOD R3, M66
LOD R4, M47
ADD R1, R3, R4
DEC R1, R1
.BRLend
JMP .Loop3

.Jump
CAL .Get1op
LOD R4, M47
ADD R1, R4, R3
DEC R1, R1
JMP .Loop3

.LoadMemory
CAL .Get2op
LOD R3, R3
STR R2, R3
JMP .Loop3

.StoreMemory
CAL .Get2op
STR R4, R3
JMP .Loop3

.Move
CAL .Get2op
STR R2, R3
JMP .Loop3

.Push
CAL .Get1op
PSH R3
STR M67, SP
JMP .Loop3

.Pop
CAL .Get1op
POP R3
STR R2, R3
STR M67, SP
JMP .Loop3

.Call
CAL .Get1op
LOD R4, M47
ADD R4, R4, R3
MOV R1, R3
DEC R1, R1
PSH R4
JMP .Loop3

.Return
POP R1
JMP .Loop3

.Add2Word //award for most painful instruction to impliment
AND R2, R4, 0xF000 // R2 = op1
BSR R2, R2, 12
ADD R2, R2, M51
PSH R2
LOD R2, R2
LLOD R3, R2, 1
AND R4, R4, 0x0F00 // R4 = op2
BSR R4, R4, 8
ADD R4, R4, M51
PSH R4
LOD R4, R4
BNC .AddNoCarry, R4, R2
INC R3, R3
.AddNoCarry
ADD R4, R4, R2
POP R2
LLOD R2, R2, 1
ADD R3, R3, R2
POP R2
STR R2, R4
LSTR R2, 1, R3
JMP .Loop3

.Increment
CAL .Get1op
INC R3, R3
STR R2, R3
JMP .Loop3

.Decrement
CAL .Get1op
INC R3, R3
STR R2, R3
JMP .Loop3

.SystemCall
AND R2, R4, 0x0FE0 // R2 = op1
BSR R2, R2, 5
ADD R2, R2, M32 // Add offset
LOD R3, R2 // Load jump address
JMP R3

.Halt
JMP .ShellEnd

//System Calls
.Exit
HLT

.DriveAddr
CAL .Get1op
OUT %ADDR, R3
JMP .Loop3

.DriveRead
CAL .Get1op
IN R3, %BUS
JMP .Loop3

.DriveWrite
CAL .Get1op
OUT %BUS, R3
JMP .Loop3

.CallProgram
CAL .Get1op
.CallprogramOpPresent
STR M47, R3 //set pointer
MOV R1, R3 //set program counter
STR M51, 0 //set 0 reg
JMP .Loop3

.CallProgramFromDirectory
CAL .Get1op
BSL R3, R3, 2 //mult by 4
ADD R3, R3, 3
LOD R4, M68 //.CurrentWorkingDirectory load current working directory
ADD R3, R3, R4 //add offset
LOD R3, R3 //load address
JMP .CallprogramOpPresent

.DeviceNumber
CAL .Get1op
OUT %PROFILE, R3
JMP .Loop3

.InChar
AND R2, R4, 0xF000 // R2 = op1
BSR R2, R2, 12
ADD R2, R2, M51
IN R3, %TEXT
STR R2, R3
JMP .Loop3

.OutChar
CAL .Get1op
OUT %TEXT, R3
JMP .Loop3

.InString // Coming soon
.OutString // Coming soon
JMP .Error

.InHex
AND R2, R4, 0xF000 // R2 = op1
BSR R2, R2, 12
ADD R2, R2, M51
PSH R2
IMM R4, 16
IMM R2, 0
.Loop4
SUB R4, R4, 4
IN R3, %TEXT
SUB R3, R3, 0x30
BRL .HexInSkip, R3, 0xA
SUB R3, R3, 7
.HexInSkip
BSL R3, R3, R4
OR R2, R2, R3
BNZ .Loop4, R4
POP R3
STR R3, R2
JMP .Loop3

.OutHex
AND R2, R4, 0xF000 // R2 = op1
BSR R2, R2, 12
ADD R2, R2, M51
LOD R3, R2
AND R3, R3, 0xF000
BSR R3, R3, 12
ADD R3, R3, 0x30
BRL .HexOut1, R3, 0x3A
ADD R3, R3, 7
.HexOut1
OUT %TEXT, R3
AND R3, R2, 0x0F00
AND R4, R2, 0x00F0
AND R2, R2, 0x000F
BSR R3, R3, 8
BSR R4, R4, 4
ADD R3, R3, 0x30
BRL .HexOut2, R3, 0x3A
ADD R3, R3, 7
.HexOut2
OUT %TEXT, R3
ADD R4, R4, 0x30
BRL .HexOut3, R4, 0x3A
ADD R4, R4, 7
.HexOut3
OUT %TEXT, R4
ADD R2, R2, 0x30
BRL .HexOut4, R2, 0x3A
ADD R2, R2, 7
.HexOut4
OUT %TEXT, R2
JMP .Loop3

.ChangeWorkingDirectory
CAL .Get1op
STR M68, R3 //.CurrentWorkingDirectory
JMP .Loop3

.ChangeWorkingDirectoryFromCurrent
CAL .Get1op
BRE .CDFCroot, R3, 0xFFFF
BSL R3, R3, 2 //mult by 4
ADD R3, R3, 3
LOD R4, M68 //.CurrentWorkingDirectory load current working directory
ADD R3, R3, R4 //add offset
LOD R3, R3 //load address
STR M68, R3 //.CurrentWorkingDirectory
JMP .Loop3
.CDFCroot
LOD R3, M69 //.RootDirectory
STR M68, M76 //.CurrentWorkingDirectory .Files
JMP .Loop3

//* EXTRA FUNCTIONS *//
.Error
OUT %TEXT, 0x45 // 'E'
OUT %TEXT, 0x72 // 'r'
OUT %TEXT, 0x72 // 'r'
OUT %TEXT, 0x6F // 'o'
OUT %TEXT, 0x72 // 'r'
OUT %TEXT, 0xA // '\n'
JMP .ShellEnd

.Get2op
AND R2, R4, 0xF000 // R2 = op1
AND R3, R4, 0x0F00 // R3 = op2
BSR R2, R2, 12
BSR R3, R3, 8
ADD R2, M51, R2 // Add offset
ADD R3, M51, R3
LOD R4, R2
LOD R3, R3 // Load values
RET

.Get1op
AND R2, R4, 0xF000 // R2 = op1
BSR R2, R2, 12
ADD R2, R2, M51
LOD R3, R2
RET
