// THIS IS A BETA AND BUGS MAY BE PRESENT

// URCL OS v2

// Whats new in v2:
// Rewrite of all functions
// New intermediate language
// Terminal upgrades (more to come as well)
// Directories
// New file header format (easier to access information and scales better)

// Included programs: ls (0 or /0/0), cd (1 or /0/1)

// URCL HEADER
BITS >= 16
MINREG 4
MINHEAP 200
MINSTACK 6

// Load files (using STR)
// / (root)
// Format: {name} {format} {length} {address} (8 files in root)
STR M76, 0x0262
STR M77, 0x0001
STR M78, 0x0009
STR M79, M114
STR M80, 0
// /0 (/bin)
STR M108, 0x0262 //3 long name starts with b (bin)
STR M109, 0x0001 //format: directory
STR M110, 0x0009 //length
STR M111, M114 //address of start
STR M112, 0x0069 //continuation of name (i)
STR M113, 0x006E //continuation of name (n)
STR M114, 0x016C //2 long name starts with l (ls)
STR M115, 0x0000 //format: program
STR M116, 0x002C //length
STR M117, M129 //address of start
STR M118, 0x0163 //2 long name starts with c (cd)
STR M119, 0x0000 //format: program
STR M120, 0x0008 //length
STR M121, M180
STR M122, 0 //padding
STR M123, 0 //padding between files
// /0/0 (/bin/ls)
STR M124, 0x016C //2 long name starts with l (ls)
STR M125, 0x0000 //format: program
STR M126, 0x002C //length
STR M127, M129 //address of start
STR M128, 0x0073 //continuation of name (s)
STR M129, 0x7001 //imm r7, 0x000A '0'
STR M130, 0x000A //immediate word
STR M131, 0x8001 //imm r8, 8
STR M132, 0x0008 //immediate word
STR M133, 0x9001 //imm r9, 0x00FF
STR M134, 0x00FF //immediate word
STR M135, 0xA001 //imm r10, 0x3A ':'
STR M136, 0x003A //immediate word
STR M137, 0xB001 //imm r11, 0x20 ' '
STR M138, 0x0020 //immediate word
STR M139, 0xC001 //imm r12, 3
STR M140, 0x0003 //immediate word
STR M141, 0xD001 //imm r13, .loop
STR M142, 0x0015 //immediate word
STR M143, 0xE001 //imm r14, .loop2
STR M144, 0x0024 //immediate word
STR M145, 0xF001 //imm r15, .end
STR M146, 0x002B //immediate word
STR M147, 0x5001 //imm r5, 0x30 ('0')
STR M148, 0x0030 //immediate word
STR M149, 0x401C //dec r4
STR M150, 0x401B //inc r4 (.loop)
STR M151, 0x1413 //lod r1, r4
STR M152, 0xF10C //brz r15, r1
STR M153, 0x2115 //mov r2, r1
STR M154, 0x280B //bsr r2, r8 (8)
STR M155, 0x1908 //and r1, r9
STR M156, 0x511D //outc r5
STR M157, 0xA11D //outc r10
STR M158, 0xB11D //outc r11
STR M159, 0x111D //outc r1
STR M160, 0x501B //inc r5
STR M161, 0x4C02 //add r4, r12
STR M162, 0xD20C //brz r13, r2
STR M163, 0x1413 //lod r1, r4
STR M164, 0x1203 //sub r1, r2
STR M165, 0x6113 //lod r6, r1 (.loop2)
STR M166, 0x611D //outc r6
STR M167, 0x201C //dec r2
STR M168, 0x101B //inc r1
STR M169, 0xE20D //bnz r14, r2
STR M170, 0x711D //outc r7
STR M171, 0xD012 //jmp r13
STR M172, 0x001E //hlt
STR M173, 0
STR M174, 0
// /0/1 (/bin/cd)
STR M175, 0x0163 //2 long name starts with c (cd)
STR M176, 0x0000 //format: program
STR M177, 0x000E //length
STR M178, M180 //address of start
STR M179, 0x0064 //continuation of name (d)
STR M180, 0x2017 //pop r2
STR M181, 0xF001 //imm r15, 0xb (.root)
STR M182, 0x000B //immediate word
STR M183, 0x1001 //imm r1, 0x30
STR M184, 0x0030 //immediate word
STR M185, 0x2103 //sub r2, r1
STR M186, 0x21DD //cdFromCurrent r2
STR M187, 0x001E // hlt

.Initialize
// Instruction to Address Table
.InstructionTable
STR M0, 0
STR M1, .Immediate // 1
STR M2, .Add // 2
STR M3, .Subtract // 3
STR M4, .Multiply // 4
STR M5, .Divide // 5
STR M6, .Modulo // 6
STR M7, .Xor // 7
STR M8, .And // 8
STR M9, .Or // 9
STR M10, .ShiftLeft // 10
STR M11, .ShiftRight // 11
STR M12, .BranchIfZero // 12
STR M13, .BranchIfNotZero // 13
STR M14, .BranchIfEqual // 14
STR M15, .BranchIfNotEqual // 15
STR M16, .BranchIfLessThan // 16
STR M17, .BranchIfGreaterThan // 17
STR M18, .Jump // 18
STR M19, .LoadMemory // 19
STR M20, .StoreMemory // 20
STR M21, .Move // 21
STR M22, .Push // 22
STR M23, .Pop // 23
STR M24, .Call // 24
STR M25, .Return // 25
STR M26, .Add2Word // 26
STR M27, .Increment // 27
STR M28, .Decrement // 28
STR M29, .SystemCall // 29
STR M30, .Halt // 30
STR M31, .Error // 31

// System Calls
.SystemCalls
STR M32, .Exit // 0
STR M33, .DriveAddr // 1
STR M34, .DriveRead // 2
STR M35, .DriveWrite // 3
STR M36, .CallProgram // 4
STR M37, .CallProgramFromDirectory // 5
STR M38, .DeviceNumber // 6
STR M39, .InChar // 7
STR M40, .OutChar // 8
STR M41, .InString // 9 (Coming soon)
STR M42, .OutString // 10 (Coming soon)
STR M43, .InHex // 11
STR M44, .OutHex // 12
STR M45, .ChangeWorkingDirectory // 13
STR M46, .ChangeWorkingDirectoryFromCurrent // 14

//* Interpreter Variables *//
.Pointer // Stores the address of the next instruction to be executed
STR M47, 0x0000

.ProgramLimit // Stores the limit of the program currently executed (global address) (inclusive)
STR M48, 0x0000

//* File Scan Variables *//
.MaxFiles // Stores the maximum amount of files in the root directory multiplied by 4 (Total = maximum amount of file info words)
STR M49, 0x0020

//* Other OS Variables *//
.VirtualRegisters
STR M51, 0 // R0 (Set to 0 before each program)
STR M52, 0 // R1
STR M53, 0 // R2
STR M54, 0 // R3
STR M55, M76 // R4 //.files
STR M56, 0 // R5
STR M57, 0 // R6
STR M58, 0 // R7
STR M59, 0 // R8
STR M60, 0 // R9
STR M61, 0 // R10
STR M62, 0 // R11
STR M63, 0 // R12
STR M64, 0 // R13
STR M65, 0 // R14
.JumpDest
STR M66, 0 // Jump Dest (R15)

.Stackpointer
STR M67, SP

.CurrentWorkingDirectory
STR M68, M76 //.files

.RootDirectory
STR M69, M76 //.files

.StartupProgram // Coming soon
STR M70, 0

//* Constants *//
.ProgramMemoryLimit // Stores the limit of the memory for programs (inclusive)
STR M71, 0xFFFF // 65535

.Runram // Stores whether cpu is runram (1 if runram, 0 if runrom)
STR M72, 0

.Bits // Stores the amount of bits of the cpu
//STR M74, 0 //incase &BITS does not work in compiler/emulator (cough cough mod)
STR M73, &BITS

.MemoryAvailable // Stores the amount of memory available to the cpu
STR M74, 0xFFFF

.Mem0
STR M75, M76

JMP .Shell
.ShellEnd
POP R1
BNE .ShellEnd, R1, 0
.Shell
OUT %TEXT, 0x24
PSH 0
MOV R2, SP
.ShellLoop
IN R1, %TEXT
OUT %TEXT, R1
PSH R1
BNE .ShellLoop, R1, 0xA
//if first char null or : exit
LOD R1, M68 //.CurrentWorkingDirectory
DEC R2, R2
LOD R3, R2
BRE .ShellEnd, R3, 0xA // Exit if null
BRE .ShellEnd, R3, 0x3A // Exit if ':'
BRE .ChangeToRoot, R3, 0x2F
BRE .FileFindLoop, R3, 0x2E
//if first char not / look in /bin
LOD R4, M69 //.RootDirectory
LLOD R4, R4, 3
STR M68, R4 //.CurrentWorkingDirectory
JMP .FileFindLoopSkipDec
//if first char / follow directory starting from root
.ChangeToRoot
LOD R4, M69 //.RootDirectory
STR M68, R4 //.CurrentWorkingDirectory
//if first char . follow directory from current
.FileFindLoop
DEC R2, R2
LOD R3, R2
.FileFindLoopSkipDec
BRE .FileFindLoop, R3, 0x2F //ignore if slash
BRE .ProgramFound, R3, 0xA
BRE .ProgramFound, R3, 0x20
SUB R3, R3, 0x30
LOD R4, M68 //.CurrentWorkingDirectory
BSL R3, R3, 2
ADD R3, R3, 3
ADD R4, R3, R4
LOD R3, R4
STR M68, R3 //.CurrentWorkingDirectory
JMP .FileFindLoop
.ProgramFound
LOD R2, M68 //.CurrentWorkingDirectory
BRZ .Error, R2 //exit if fake offbrand directory
STR M68, R1 //.CurrentWorkingDirectory reset wd
STR M55, R1 //R4
POP R1
//jump to program

.RunProgram
    //IN R1, %TEXT // Get file index
    //OUT %TEXT, R1
    //SUB R1, R1, 0x30 // Move it to "0" = 0
    //BSL R1, R1, 2 // Multiply it by 4 to get an address to the file table
    //ADD R1, R1, 3 // Point it to the global address
    //LOD R2, .MaxFiles
    //BRG .Error, R1, R2
    //LOD R2, .CurrentWorkingDirectory
    //ADD R1, R1, R2 // Point to the file table
    //LOD R2, R1
    STR M47, R2 // .Pointer = R2
    DEC R1, R2
    //set .ProgramLimit to the limit of the file (inclusive) (read description of the variable)
    LLOD R4, R4, -1
    ADD R2, R2, R4
    STR M48, R2
  
.InterpretationLoop // The loop that is ran for running a program (calling .Execute per instruction)
    // Prepare for next program being executed (reset variables)
    STR M51, 0 // Set R0 to 0
    
    // R1 = Pointer
    // R3 = Temp
    .Loop3
        INC R1, R1 // Update PC
        // Check if reached the end of a program
        LOD R3, M48
        BRG .ShellEnd, R1, R3

        // R4 = full operation
        // R2 = instruction
        LOD R4, R1 // R2 = mem[R1(pointer)]
        AND R2, R4, 0x001F // instruction = R2

        .Execute
            BRZ .Loop3, R2 //exit if no instruction
            ADD R2, R2, M0 //add offset to instruction table
            LOD R2, R2 //load jump address
            JMP R2 //call instruction

    .EndLoop3

//* INSTRUCTIONS *//

// 11112222000IIIII
// I = instruction
// 1, 2 = operand
// 0 = only used in system call
.Immediate
AND R2, R4, 0xF000 // R2 = op1
BSR R2, R2, 12
INC R1, R1 // Inc pointer
LOD R3, R1 // Load the immediate
ADD R2, M51, R2 // Add offset
STR R2, R3 // Store the immediate
JMP .Loop3

.Add
CAL .Get2op
ADD R4, R4, R3 // Do the addition
STR R2, R4
JMP .Loop3

.Subtract
CAL .Get2op
SUB R4, R4, R3 // Do the subtraction
STR R2, R4
JMP .Loop3

.Multiply
CAL .Get2op
MLT R4, R4, R3 // Do the multiplication
STR R2, R4
JMP .Loop3

.Divide
CAL .Get2op
DIV R4, R4, R3 // Do the division
STR R2, R4
JMP .Loop3

.Modulo
CAL .Get2op
MOD R4, R4, R3 // Do the modulo
STR R2, R4
JMP .Loop3

.Xor
CAL .Get2op
XOR R4, R4, R3 // Do the bitwise xor
STR R2, R4
JMP .Loop3

.And
CAL .Get2op
AND R4, R4, R3 // Do the bitwise and
STR R2, R4
JMP .Loop3

.Or
CAL .Get2op
OR R4, R4, R3 // Do the bitwise or
STR R2, R4
JMP .Loop3

.ShiftLeft
CAL .Get2op
BSL R3, R4, R3
STR R2, R3
JMP .Loop3

.ShiftRight
CAL .Get2op
BSR R3, R4, R3
STR R2, R3
JMP .Loop3

.BranchIfZero
CAL .Get2op
BNZ .BRZend, R3
LOD R3, M47
ADD R4, R4, R3
MOV R1, R4
DEC R1, R1
.BRZend
JMP .Loop3

.BranchIfNotZero
CAL .Get2op
BRZ .BNZend, R3
LOD R3, M47
ADD R4, R4, R3
MOV R1, R4
DEC R1, R1
.BNZend
JMP .Loop3

.BranchIfEqual
CAL .Get2op
BNE .BREend, R4, R3
LOD R3, M66
LOD R4, M47
ADD R1, R3, R4
DEC R1, R1
.BREend
JMP .Loop3

.BranchIfNotEqual
CAL .Get2op
BRE .BNEend, R4, R3
LOD R3, M66
LOD R4, M47
ADD R1, R3, R4
DEC R1, R1
.BNEend
JMP .Loop3

.BranchIfGreaterThan
CAL .Get2op
BLE .BRGend, R4, R3
LOD R3, M66
LOD R4, M47
ADD R1, R3, R4
DEC R1, R1
.BRGend
JMP .Loop3

.BranchIfLessThan
CAL .Get2op
BGE .BRLend, R4, R3
LOD R3, M66
LOD R4, M47
ADD R1, R3, R4
DEC R1, R1
.BRLend
JMP .Loop3

.Jump
CAL .Get1op
LOD R4, M47
ADD R1, R4, R3
DEC R1, R1
JMP .Loop3

.LoadMemory
CAL .Get2op
LOD R3, R3
STR R2, R3
JMP .Loop3

.StoreMemory
CAL .Get2op
STR R4, R3
JMP .Loop3

.Move
CAL .Get2op
STR R2, R3
JMP .Loop3

.Push
CAL .Get1op
PSH R3
STR M67, SP
JMP .Loop3

.Pop
CAL .Get1op
POP R3
STR R2, R3
STR M67, SP
JMP .Loop3

.Call
CAL .Get1op
LOD R4, M47
ADD R4, R4, R3
MOV R1, R3
DEC R1, R1
PSH R4
JMP .Loop3

.Return
POP R1
JMP .Loop3

.Add2Word //award for most painful instruction to impliment
AND R2, R4, 0xF000 // R2 = op1
BSR R2, R2, 12
ADD R2, R2, M51
PSH R2
LOD R2, R2
LLOD R3, R2, 1
AND R4, R4, 0x0F00 // R4 = op2
BSR R4, R4, 8
ADD R4, R4, M51
PSH R4
LOD R4, R4
BNC .AddNoCarry, R4, R2
INC R3, R3
.AddNoCarry
ADD R4, R4, R2
POP R2
LLOD R2, R2, 1
ADD R3, R3, R2
POP R2
STR R2, R4
LSTR R2, 1, R3
JMP .Loop3

.Increment
CAL .Get1op
INC R3, R3
STR R2, R3
JMP .Loop3

.Decrement
CAL .Get1op
DEC R3, R3
STR R2, R3
JMP .Loop3

.SystemCall
AND R2, R4, 0x0FE0 // R2 = op1
BSR R2, R2, 5
ADD R2, R2, M32 // Add offset
LOD R3, R2 // Load jump address
JMP R3

.Halt
JMP .ShellEnd

//System Calls
.Exit
HLT

.DriveAddr
CAL .Get1op
OUT %ADDR, R3
JMP .Loop3

.DriveRead
CAL .Get1op
IN R3, %BUS
JMP .Loop3

.DriveWrite
CAL .Get1op
OUT %BUS, R3
JMP .Loop3

.CallProgram
CAL .Get1op
.CallprogramOpPresent
STR M47, R3 //set pointer
MOV R1, R3 //set program counter
STR M51, 0 //set 0 reg
JMP .Loop3

.CallProgramFromDirectory
CAL .Get1op
BSL R3, R3, 2 //mult by 4
ADD R3, R3, 3
LOD R4, M68 //.CurrentWorkingDirectory load current working directory
ADD R3, R3, R4 //add offset
LOD R3, R3 //load address
JMP .CallprogramOpPresent

.DeviceNumber
CAL .Get1op
OUT %PROFILE, R3
JMP .Loop3

.InChar
AND R2, R4, 0xF000 // R2 = op1
BSR R2, R2, 12
ADD R2, R2, M51
IN R3, %TEXT
STR R2, R3
JMP .Loop3

.OutChar
CAL .Get1op
OUT %TEXT, R3
JMP .Loop3

.InString // Coming soon
.OutString // Coming soon
JMP .Error

.InHex
AND R2, R4, 0xF000 // R2 = op1
BSR R2, R2, 12
ADD R2, R2, M51
PSH R2
IMM R4, 16
IMM R2, 0
.Loop4
SUB R4, R4, 4
IN R3, %TEXT
SUB R3, R3, 0x30
BRL .HexInSkip, R3, 0xA
SUB R3, R3, 7
.HexInSkip
BSL R3, R3, R4
OR R2, R2, R3
BNZ .Loop4, R4
POP R3
STR R3, R2
JMP .Loop3

.OutHex
AND R2, R4, 0xF000 // R2 = op1
BSR R2, R2, 12
ADD R2, R2, M51
LOD R3, R2
AND R3, R3, 0xF000
BSR R3, R3, 12
ADD R3, R3, 0x30
BRL .HexOut1, R3, 0x3A
ADD R3, R3, 7
.HexOut1
OUT %TEXT, R3
AND R3, R2, 0x0F00
AND R4, R2, 0x00F0
AND R2, R2, 0x000F
BSR R3, R3, 8
BSR R4, R4, 4
ADD R3, R3, 0x30
BRL .HexOut2, R3, 0x3A
ADD R3, R3, 7
.HexOut2
OUT %TEXT, R3
ADD R4, R4, 0x30
BRL .HexOut3, R4, 0x3A
ADD R4, R4, 7
.HexOut3
OUT %TEXT, R4
ADD R2, R2, 0x30
BRL .HexOut4, R2, 0x3A
ADD R2, R2, 7
.HexOut4
OUT %TEXT, R2
JMP .Loop3

.ChangeWorkingDirectory
CAL .Get1op
STR M68, R3 //.CurrentWorkingDirectory
JMP .Loop3

.ChangeWorkingDirectoryFromCurrent
CAL .Get1op
BRE .CDFCroot, R3, 0xFFFF
BSL R3, R3, 2 //mult by 4
ADD R3, R3, 3
LOD R4, M68 //.CurrentWorkingDirectory load current working directory
ADD R3, R3, R4 //add offset
LOD R3, R3 //load address
STR M68, R3 //.CurrentWorkingDirectory
JMP .Loop3
.CDFCroot
LOD R3, M69 //.RootDirectory
STR M68, M76 //.CurrentWorkingDirectory .Files
JMP .Loop3

//* EXTRA FUNCTIONS *//
.Error
OUT %TEXT, 0x45 // 'E'
OUT %TEXT, 0x72 // 'r'
OUT %TEXT, 0x72 // 'r'
OUT %TEXT, 0x6F // 'o'
OUT %TEXT, 0x72 // 'r'
OUT %TEXT, 0xA // '\n'
JMP .ShellEnd

.Get2op
AND R2, R4, 0xF000 // R2 = op1
AND R3, R4, 0x0F00 // R3 = op2
BSR R2, R2, 12
BSR R3, R3, 8
ADD R2, M51, R2 // Add offset
ADD R3, M51, R3
LOD R4, R2
LOD R3, R3 // Load values
RET

.Get1op
AND R2, R4, 0xF000 // R2 = op1
BSR R2, R2, 12
ADD R2, R2, M51
LOD R3, R2
RET
