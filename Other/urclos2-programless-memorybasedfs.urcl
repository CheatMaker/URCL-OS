// THIS IS AN OUTDATED VERSION OF URCL-OS
// this exists for systems with no storage other than RAM

// No programs are included in this version

// URCL HEADER
BITS >= 16
MINREG 4
MINHEAP 128
MINSTACK 6

// Load files here (using STR)
// / (root dir) (M0-M32)
STR M0, 0

JMP .Initialize
// Instruction to Address Table
.InstructionTable
DW 0
DW .Immediate // 1
DW .Add // 2
DW .Subtract // 3
DW .Multiply // 4
DW .Divide // 5
DW .Modulo // 6
DW .Xor // 7
DW .And // 8
DW .Or // 9
DW .ShiftLeft // 10
DW .ShiftRight // 11
DW .BranchIfZero // 12
DW .BranchIfNotZero // 13
DW .BranchIfEqual // 14
DW .BranchIfNotEqual // 15
DW .BranchIfLessThan // 16
DW .BranchIfGreaterThan // 17
DW .Jump // 18
DW .LoadMemory // 19
DW .StoreMemory // 20
DW .Move // 21
DW .Push // 22
DW .Pop // 23
DW .Call // 24
DW .Return // 25
DW .Add2Word // 26
DW .Increment // 27
DW .Decrement // 28
DW .SystemCall // 29
DW .Halt // 30
DW .Error // 31

// System Calls
.SystemCalls
DW .Exit // 0
DW .DriveAddr // 1
DW .DriveRead // 2
DW .DriveWrite // 3
DW .CallProgram // 4
DW .CallProgramFromDirectory // 5
DW .DeviceNumber // 6
DW .InChar // 7
DW .OutChar // 8
DW .InString // 9 (Coming soon)
DW .OutString // 10 (Coming soon)
DW .InHex // 11
DW .OutHex // 12
DW .ChangeWorkingDirectory // 13
DW .ChangeWorkingDirectoryFromCurrent // 14

//* Interpreter Variables *//
.Pointer // Stores the address of the next instruction to be executed
DW 0x0000

.ProgramLimit // Stores the limit of the program currently executed (global address) (inclusive)
DW 0x0000

//* File Scan Variables *//
.MaxFiles // Stores the maximum amount of files in the root directory multiplied by 4 (Total = maximum amount of file info words)
DW 0x0020

.LengthOfFile // Stores the length of the file
DW 0x0000

//* Other OS Variables *//
.VirtualRegisters
DW 0 // R0 (Set to 0 before each program)
DW 0 // R1
DW 0 // R2
DW 0 // R3
.R4
DW M0 // R4
DW 0 // R5
DW 0 // R6
DW 0 // R7
DW 0 // R8
DW 0 // R9
DW 0 // R10
DW 0 // R11
DW 0 // R12
DW 0 // R13
DW 0 // R14
.JumpDest
DW 0 // Jump Dest (R15)

.Stackpointer
DW 0

.CurrentWorkingDirectory
DW M0

.RootDirectory
DW M0

.StartupProgram // Coming soon
DW 0

//* Constants *//
.ProgramMemoryLimit // Stores the limit of the memory for programs (inclusive)
DW 0xFFFF // 65535

.Runram // Stores whether cpu is runram (1 if runram, 0 if runrom)
DW 1

.Bits // Stores the amount of bits of the cpu
//DW 0 //incase &BITS does not work in compiler/emulator (cough cough mod)
DW &BITS

.MemoryAvailable // Stores the amount of memory available to the cpu
DW 0xFFFF

.Mem0
DW M0

.Initialize
STR .Stackpointer, SP //initialize starting sp

JMP .Shell
.ShellEnd
POP R1
BNE .ShellEnd, R1, 0
.Shell
OUT %TEXT, 0x24
PSH 0
MOV R2, SP
.ShellLoop
IN R1, %TEXT
OUT %TEXT, R1
BRE .Backspace, R1, 0x8
PSH R1
BNE .ShellLoop, R1, 0xA
//if first char null or : exit
LOD R1, .CurrentWorkingDirectory
DEC R2, R2
LOD R3, R2
BRE .ShellEnd, R3, 0xA // Exit if null
BRE .ShellEnd, R3, 0x3A // Exit if ':'
BRE .ChangeToRoot, R3, 0x2F
BRE .FileFindLoop, R3, 0x2E
//if first char not / look in /bin
LOD R4, .RootDirectory
LLOD R4, R4, 3
STR .CurrentWorkingDirectory, R4
JMP .FileFindLoopSkipDec
//if first char / follow directory starting from root
.ChangeToRoot
LOD R4, .RootDirectory
STR .CurrentWorkingDirectory, R4
//if first char . follow directory from current
.FileFindLoop
DEC R2, R2
LOD R3, R2
.FileFindLoopSkipDec
BRE .FileFindLoop, R3, 0x2F //ignore if slash
BRE .ProgramFound, R3, 0xA
BRE .ProgramFound, R3, 0x20
SUB R3, R3, 0x30
LOD R4, .CurrentWorkingDirectory
BSL R3, R3, 2
ADD R3, R3, 3
ADD R4, R3, R4
LOD R3, R4
STR .CurrentWorkingDirectory, R3
JMP .FileFindLoop
.ProgramFound
LOD R2, .CurrentWorkingDirectory
BRZ .Error, R2 //exit if fake offbrand directory
STR .CurrentWorkingDirectory, R1 //reset wd
BGE .SubWDSkip, R1, M0
SUB R1, R1, .InstructionTable
.SubWDSkip
STR .R4, R1
POP R1
//jump to program

.RunProgram
    //IN R1, %TEXT // Get file index
    //OUT %TEXT, R1
    //SUB R1, R1, 0x30 // Move it to "0" = 0
    //BSL R1, R1, 2 // Multiply it by 4 to get an address to the file table
    //ADD R1, R1, 3 // Point it to the global address
    //LOD R2, .MaxFiles
    //BRG .Error, R1, R2
    //LOD R2, .CurrentWorkingDirectory
    //ADD R1, R1, R2 // Point to the file table
    //LOD R2, R1
    STR .Pointer, R2 // .Pointer = R1
    DEC R1, R2
    //set .ProgramLimit to the limit of the file (inclusive) (read description of the variable)
    LLOD R4, R4, -1
    ADD R2, R2, R4
    STR .ProgramLimit, R2

    
.InterpretationLoop // The loop that is ran for running a program (calling .Execute per instruction)
    // Prepare for next program being executed (reset variables)
    STR .VirtualRegisters, 0 // Set R0 to 0
    
    // R1 = Pointer
    // R3 = Temp
    .Loop3
        INC R1, R1 // Update PC
        // Check if reached the end of a program
        LOD R3, .ProgramLimit
        BRG .ShellEnd, R1, R3

        // R4 = full operation
        // R2 = instruction
        LOD R4, R1 // R2 = mem[R1(pointer)]
        AND R2, R4, 0x001F // instruction = R2

        .Execute
            BRZ .Loop3, R2 //exit if no instruction
            ADD R2, R2, .InstructionTable //add offset to instruction table
            LOD R2, R2 //load jump address
            JMP R2 //call instruction

    .EndLoop3

//* INSTRUCTIONS *//

// 11112222000IIIII
// I = instruction
// 1, 2 = operand
// 0 = only used in system call
.Immediate
AND R2, R4, 0xF000 // R2 = op1
BSR R2, R2, 12
INC R1, R1 // Inc pointer
LOD R3, R1 // Load the immediate
ADD R2, .VirtualRegisters, R2 // Add offset
STR R2, R3 // Store the immediate
JMP .Loop3

.Add
CAL .Get2op
ADD R4, R4, R3 // Do the addition
STR R2, R4
JMP .Loop3

.Subtract
CAL .Get2op
SUB R4, R4, R3 // Do the subtraction
STR R2, R4
JMP .Loop3

.Multiply
CAL .Get2op
MLT R4, R4, R3 // Do the multiplication
STR R2, R4
JMP .Loop3

.Divide
CAL .Get2op
DIV R4, R4, R3 // Do the division
STR R2, R4
JMP .Loop3

.Modulo
CAL .Get2op
MOD R4, R4, R3 // Do the modulo
STR R2, R4
JMP .Loop3

.Xor
CAL .Get2op
XOR R4, R4, R3 // Do the bitwise xor
STR R2, R4
JMP .Loop3

.And
CAL .Get2op
AND R4, R4, R3 // Do the bitwise and
STR R2, R4
JMP .Loop3

.Or
CAL .Get2op
OR R4, R4, R3 // Do the bitwise or
STR R2, R4
JMP .Loop3

.ShiftLeft
CAL .Get2op
BSL R3, R4, R3
STR R2, R3
JMP .Loop3

.ShiftRight
CAL .Get2op
BSR R3, R4, R3
STR R2, R3
JMP .Loop3

.BranchIfZero
CAL .Get2op
BNZ .BRZend, R3
LOD R3, .Pointer
ADD R4, R4, R3
MOV R1, R4
DEC R1, R1
.BRZend
JMP .Loop3

.BranchIfNotZero
CAL .Get2op
BRZ .BNZend, R3
LOD R3, .Pointer
ADD R4, R4, R3
MOV R1, R4
DEC R1, R1
.BNZend
JMP .Loop3

.BranchIfEqual
CAL .Get2op
BNE .BREend, R4, R3
LOD R3, .JumpDest
LOD R4, .Pointer
ADD R1, R3, R4
DEC R1, R1
.BREend
JMP .Loop3

.BranchIfNotEqual
CAL .Get2op
BRE .BNEend, R4, R3
LOD R3, .JumpDest
LOD R4, .Pointer
ADD R1, R3, R4
DEC R1, R1
.BNEend
JMP .Loop3

.BranchIfGreaterThan
CAL .Get2op
BLE .BRGend, R4, R3
LOD R3, .JumpDest
LOD R4, .Pointer
ADD R1, R3, R4
DEC R1, R1
.BRGend
JMP .Loop3

.BranchIfLessThan
CAL .Get2op
BGE .BRLend, R4, R3
LOD R3, .JumpDest
LOD R4, .Pointer
ADD R1, R3, R4
DEC R1, R1
.BRLend
JMP .Loop3

.Jump
CAL .Get1op
LOD R4, .Pointer
ADD R1, R4, R3
DEC R1, R1
JMP .Loop3

.LoadMemory
CAL .Get2op
BGE .OutOfSource, R3, M0
ADD R3, R3, .InstructionTable
.OutOfSource
LOD R3, R3
STR R2, R3
JMP .Loop3

.StoreMemory
CAL .Get2op
BGE .OutOfSource2, R4, M0
ADD R4, R4, .InstructionTable
.OutOfSource2
STR R4, R3
JMP .Loop3

.Move
CAL .Get2op
STR R2, R3
JMP .Loop3

.Push
CAL .Get1op
PSH R3
STR .Stackpointer, SP
JMP .Loop3

.Pop
CAL .Get1op
POP R3
STR R2, R3
STR .Stackpointer, SP
JMP .Loop3

.Call
CAL .Get1op
LOD R4, .Pointer
ADD R4, R4, R3
MOV R1, R3
DEC R1, R1
PSH R4
JMP .Loop3

.Return
POP R1
JMP .Loop3

.Add2Word //award for most painful instruction to impliment
AND R2, R4, 0xF000 // R2 = op1
BSR R2, R2, 12
ADD R2, R2, .VirtualRegisters
PSH R2
LOD R2, R2
LLOD R3, R2, 1
AND R4, R4, 0x0F00 // R4 = op2
BSR R4, R4, 8
ADD R4, R4, .VirtualRegisters
PSH R4
LOD R4, R4
BNC .AddNoCarry, R4, R2
INC R3, R3
.AddNoCarry
ADD R4, R4, R2
POP R2
LLOD R2, R2, 1
ADD R3, R3, R2
POP R2
STR R2, R4
LSTR R2, 1, R3
JMP .Loop3

.Increment
CAL .Get1op
INC R3, R3
STR R2, R3
JMP .Loop3

.Decrement
CAL .Get1op
DEC R3, R3
STR R2, R3
JMP .Loop3

.SystemCall
AND R2, R4, 0x0FE0 // R2 = op1
BSR R2, R2, 5
ADD R2, R2, .SystemCalls // Add offset
LOD R3, R2 // Load jump address
JMP R3

.Halt
JMP .ShellEnd

//System Calls
.Exit
HLT

.DriveAddr
CAL .Get1op
OUT %ADDR, R3
JMP .Loop3

.DriveRead
CAL .Get1op
IN R3, %BUS
JMP .Loop3

.DriveWrite
CAL .Get1op
OUT %BUS, R3
JMP .Loop3

.CallProgram
CAL .Get1op
.CallprogramOpPresent
STR .Pointer, R3 //set pointer
MOV R1, R3 //set program counter
STR .VirtualRegisters, 0 //set 0 reg
JMP .Loop3

.CallProgramFromDirectory
CAL .Get1op
BSL R3, R3, 2 //mult by 4
ADD R3, R3, 3
LOD R4, .CurrentWorkingDirectory //load current working directory
ADD R3, R3, R4 //add offset
LOD R3, R3 //load address
JMP .CallprogramOpPresent

.DeviceNumber
CAL .Get1op
OUT %PROFILE, R3
JMP .Loop3

.InChar
AND R2, R4, 0xF000 // R2 = op1
BSR R2, R2, 12
ADD R2, R2, .VirtualRegisters
IN R3, %TEXT
STR R2, R3
JMP .Loop3

.OutChar
CAL .Get1op
OUT %TEXT, R3
JMP .Loop3

.InString // Coming soon
.OutString // Coming soon
JMP .Error

.InHex
AND R2, R4, 0xF000 // R2 = op1
BSR R2, R2, 12
ADD R2, R2, .VirtualRegisters
PSH R2
IMM R4, 16
IMM R2, 0
.Loop4
SUB R4, R4, 4
IN R3, %TEXT
SUB R3, R3, 0x30
BRL .HexInSkip, R3, 0xA
SUB R3, R3, 7
.HexInSkip
BSL R3, R3, R4
OR R2, R2, R3
BNZ .Loop4, R4
POP R3
STR R3, R2
JMP .Loop3

.OutHex
AND R2, R4, 0xF000 // R2 = op1
BSR R2, R2, 12
ADD R2, R2, .VirtualRegisters
LOD R3, R2
AND R3, R3, 0xF000
BSR R3, R3, 12
ADD R3, R3, 0x30
BRL .HexOut1, R3, 0x3A
ADD R3, R3, 7
.HexOut1
OUT %TEXT, R3
AND R3, R2, 0x0F00
AND R4, R2, 0x00F0
AND R2, R2, 0x000F
BSR R3, R3, 8
BSR R4, R4, 4
ADD R3, R3, 0x30
BRL .HexOut2, R3, 0x3A
ADD R3, R3, 7
.HexOut2
OUT %TEXT, R3
ADD R4, R4, 0x30
BRL .HexOut3, R4, 0x3A
ADD R4, R4, 7
.HexOut3
OUT %TEXT, R4
ADD R2, R2, 0x30
BRL .HexOut4, R2, 0x3A
ADD R2, R2, 7
.HexOut4
OUT %TEXT, R2
JMP .Loop3

.ChangeWorkingDirectory
CAL .Get1op
STR .CurrentWorkingDirectory, R3
JMP .Loop3

.ChangeWorkingDirectoryFromCurrent
CAL .Get1op
BRE .CDFCroot, R3, 0xFFFF
BSL R3, R3, 2 //mult by 4
ADD R3, R3, 3
LOD R4, .CurrentWorkingDirectory //load current working directory
ADD R3, R3, R4 //add offset
LOD R3, R3 //load address
STR .CurrentWorkingDirectory, R3
JMP .Loop3
.CDFCroot
LOD R3, .RootDirectory
STR .CurrentWorkingDirectory, R3
JMP .Loop3

//* EXTRA FUNCTIONS *//
.Error
OUT %TEXT, 0x45 // 'E'
OUT %TEXT, 0x72 // 'r'
OUT %TEXT, 0x72 // 'r'
OUT %TEXT, 0x6F // 'o'
OUT %TEXT, 0x72 // 'r'
OUT %TEXT, 0xA // '\n'
JMP .ShellEnd

.Get2op
AND R2, R4, 0xF000 // R2 = op1
AND R3, R4, 0x0F00 // R3 = op2
BSR R2, R2, 12
BSR R3, R3, 8
ADD R2, .VirtualRegisters, R2 // Add offset
ADD R3, .VirtualRegisters, R3
LOD R4, R2
LOD R3, R3 // Load values
RET

.Get1op
AND R2, R4, 0xF000 // R2 = op1
BSR R2, R2, 12
ADD R2, R2, .VirtualRegisters
LOD R3, R2
RET

.Backspace
POP R1
JMP .ShellLoop